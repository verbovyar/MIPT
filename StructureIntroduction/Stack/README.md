# My stack

В этом проекте реализована структура данных **stack** с использованием динамического массива, подробнее можно прочитать в [google](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA).

***Команды стека***         
Для начала рассмотрим команды, которые может выполнять наша структура данных:
``` C++
void     Push        (myStack* stack, int value);
void     Pop         (myStack* stack);
void     DeleteStack (myStack* stack);
void     ClearStack  (myStack* stack);
elem_t   Top         (myStack* stack);
myStack* NewStack    (size_t start_size);
```
1) Функция NewStack создает структуру данных.
2) Функция DeleteStack удаляет stack.
3) Функция ClearStack очищает все данные из стека.
4) Команда Push позваоляет вставить элемент в вершину стека.
5) Команда Top позволяет получить значение элемента из вершины стека.
6) Команда Pop удаляет элемент из вершины стека.                

***Защита стека***      
Данная реализация стека защищена от неправильного использования.
Для этого реализованы функции **stackDump** и **stackOk**.
``` C++
STACK_ERROR stackOk   (myStack* stack);
void        stackDump (myStack* stack);
``` 
Функция **stackOk** проверяет стек по 8 критериям и в случае неправильного использования возвращает код ошибки:
``` C++
enum STACK_ERROR
{
  SIZE_ERROR,
  POINTER_ERROR,
  POP_ERROR,
  STACK_POINTER_ERROR,
  CONSTRUCT_ERROR,
  STRUCT_ERROR,
  ARRAY_ERROR,
  HASH_ERROR,
  NO_ERROR
};
``` 
Давайте подробнее рассмотрим с помощью каких методов происходит защита стека.        
1) *Канарейки*        
+========================+        
|left cnry|...|...|...|...|...|...|right cnry|                  
+========================+      
Канарейки стоят в начале массива и в конце, если пользователь каким-то образом попробует удалить элемент из пустого стека или же случайно залезет в область данных и после изменит значение одной из канареек, то stackOk отловит эту ошибку.

2) *Hash сумма*       
 Метод канареек не позволяет полность обезопасить массив от изменения в нем данных, для это существует метод хеширования данных.        
 ```C++
 uint64_t StackHash(myStack* stack)
 STACK_ERROR hashOk(myStack* stack)
 ``` 
Функция **StackHash** подсчитывает хеш-сумму элементов стека до и после работы с данными и отправляет ее в функцию **hashOk**, которая проверяет, что элементы внутри стека не были изменены, иначе она возвращает код ошибки - HASH_ERROR

***Использование защиты***      
Для того, чтобы можно было воспользоваться методами дебага, в консоли нужно прописать **-DSTACK_DEBUG** и скомпилировать остальные файлы. Это сделано для того, чтобы при правильном использовании стека не перегружать прогамму ненужными проверками, а в случае ошибки отловить ее при помощи наших методов.
```C++
#ifdef STACK_DEBUG
#define ASSERTOK(stack) if (stackOk(stack) != NO_ERROR) { stackDump(stack); assert(!"OK");	}
#else 
#define ASSERTOK(stack) ;
#endif
 ``` 
 В случае ошибки сработает assert, и в консоль выведется название функции, в которой она произошла. После будет сгенерирован *log_file*, который выведет всю информацию о стеке после последней команды.     
 Пример:
 ```
 You cant to change array(stack)!

 Left  CNRY:1000000000.........18336.000000 
 Real  CNRY:2171169.000000
 
 Right CNRY:1184274.000000 
 Real  CNRY:1184274.000000 
 
 Capacity:15
 Size:-1
 ```
